<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>UAScoin Tap Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            touch-action: manipulation;
        }

        .score-display {
            color: #FFD700;
            font-size: 6vw;
            margin: 4vh 0;
            text-shadow: 0 0 15px rgba(255,215,0,0.5);
            position: fixed;
            top: 0;
            z-index: 10;
        }

        .energy-bar {
            width: 80vw;
            height: 3vh;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            position: fixed;
            bottom: 5vh;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            transition: width 0.3s ease;
        }

        .energy-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 2vh;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        canvas {
            width: 70vmin;
            height: 70vmin;
            max-width: 400px;
            max-height: 400px;
        }
    </style>
</head>
<body>
    <div class="score-display">UAScoins: <span id="scoreDisplay">0</span></div>
    
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="energy-bar">
        <div class="energy-fill" id="energyFill"></div>
        <div class="energy-text" id="energyText">Energy: 1000/1000</div>
    </div>

    <script>
        // ======================
        // 🎮 GAME INITIALIZATION
        // ======================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const baseSize = 300;

        // High DPI Setup
        canvas.width = baseSize * dpr;
        canvas.height = baseSize * dpr;
        canvas.style.width = baseSize + 'px';
        canvas.style.height = baseSize + 'px';
        ctx.scale(dpr, dpr);

        // ======================
        // 💾 USER DATA MANAGEMENT
        // ======================
        let userData = {
            score: 0,
            energy: 1000,
            maxEnergy: 1000,
            lastUpdate: Date.now()
        };

        function loadData() {
            const saved = localStorage.getItem('uascoinData');
            if(saved) {
                userData = JSON.parse(saved);
                userData.lastUpdate = parseInt(userData.lastUpdate);
                updateEnergy();
            }
        }

        function saveData() {
            userData.lastUpdate = Date.now();
            localStorage.setItem('uascoinData', JSON.stringify(userData));
        }

        // ======================
        // ⚡ ENERGY SYSTEM
        // ======================
        function updateEnergy() {
            const now = Date.now();
            const timeDiff = now - userData.lastUpdate;
            const minutesPassed = timeDiff / (1000 * 60);
            const energyGain = Math.floor(minutesPassed / 3);
            
            if(energyGain > 0) {
                userData.energy = Math.min(
                    userData.maxEnergy,
                    userData.energy + energyGain
                );
                userData.lastUpdate = now;
                saveData();
            }
        }

        function useEnergy(amount = 1) {
            if(userData.energy >= amount) {
                userData.energy -= amount;
                return true;
            }
            return false;
        }

        // ======================
        // 🎨 GAME VISUALS
        // ======================
        const particles = [];
        const stars = Array.from({length: 100}, () => ({
            x: Math.random() * baseSize,
            y: Math.random() * baseSize,
            size: Math.random() * 1.5,
            speed: Math.random() * 0.1 + 0.05,
            alpha: Math.random() * 0.6 + 0.2
        }));

        const coinImg = new Image();
        coinImg.src = 'uascoin.png?v=3';

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, baseSize);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(1, '#1a1a3a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, baseSize, baseSize);

            ctx.fillStyle = 'white';
            stars.forEach(star => {
                star.y = (star.y + star.speed) % baseSize;
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawCoin() {
            ctx.save();
            ctx.translate(baseSize/2, baseSize/2);
            const scale = 1 + Math.sin(Date.now() / 300) * 0.05;
            ctx.scale(scale, scale);
            ctx.rotate(coinRotation += 0.01);
            
            if(coinImg.complete) {
                ctx.drawImage(coinImg, -45, -45, 90, 90);
            } else {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(0, 0, 45, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function createParticles(x, y) {
            for(let i = 0; i < 15; i++) {
                particles.push({
                    x, y,
                    size: Math.random() * 6 + 3,
                    color: `hsl(${Math.random() * 60 + 30}, 100%, 50%)`,
                    speedX: (Math.random() - 0.5) * 8,
                    speedY: (Math.random() - 0.5) * 8,
                    life: 1
                });
            }
        }

        function updateParticles() {
            particles.forEach((p, i) => {
                p.x += p.speedX;
                p.y += p.speedY;
                p.life -= 0.02;
                p.size *= 0.96;
                
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                
                if(p.life <= 0) particles.splice(i, 1);
            });
            ctx.globalAlpha = 1;
        }

        // ======================
        // 🕹️ GAME LOOP
        // ======================
        function gameLoop() {
            updateEnergy();
            
            ctx.fillStyle = 'rgba(10, 10, 20, 0.2)';
            ctx.fillRect(0, 0, baseSize, baseSize);
            
            drawBackground();
            drawCoin();
            updateParticles();
            
            document.getElementById('scoreDisplay').textContent = Math.floor(userData.score);
            const energyPercent = (userData.energy / userData.maxEnergy) * 100;
            document.getElementById('energyFill').style.width = `${energyPercent}%`;
            document.getElementById('energyText').textContent = 
                `Energy: ${userData.energy}/${userData.maxEnergy}`;
            
            requestAnimationFrame(gameLoop);
        }

        // ======================
        // 👆 INPUT HANDLING
        // ======================
        canvas.addEventListener('click', (e) => {
            if(!useEnergy(1)) {
                alert("Not enough energy!");
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const scale = baseSize / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;
            
            const dx = x - baseSize/2;
            const dy = y - baseSize/2;
            if(Math.sqrt(dx*dx + dy*dy) < 45) {
                userData.score += 1 + Math.floor(userData.score/100);
                createParticles(x, y);
                saveData();
            }
        });

        // ======================
        // 🚀 INITIALIZE
        // ======================
        loadData();
        gameLoop();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Keep previous meta tags and styles -->
    <style>
        /* Add full-screen particle container */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Previous HTML elements -->

    <script>
        // ======================
        // 🌟 PARTICLE SYSTEM MOD
        // ======================
        const ambientParticles = [];
        const MAX_PARTICLES = 200;

        function createAmbientParticle() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 3 + 1,
                color: `hsla(${Math.random() * 360}, 70%, 50%, ${Math.random() * 0.5 + 0.3})`,
                speedX: (Math.random() - 0.5) * 2,
                speedY: (Math.random() - 0.5) * 2,
                life: 1
            };
        }

        function updateAmbientParticles() {
            // Add new particles until we reach MAX_PARTICLES
            while(ambientParticles.length < MAX_PARTICLES) {
                ambientParticles.push(createAmbientParticle());
            }

            ambientParticles.forEach((p, i) => {
                // Update position
                p.x += p.speedX;
                p.y += p.speedY;
                p.life -= 0.002;

                // Reset particles that go off-screen
                if(p.x < 0 || p.x > canvas.width || 
                   p.y < 0 || p.y > canvas.height ||
                   p.life <= 0) {
                    ambientParticles[i] = createAmbientParticle();
                }

                // Draw particles
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // ======================
        // 🎮 MODIFIED GAME LOOP
        // ======================
        function gameLoop() {
            // Existing code...
            
            // Add this line before requestAnimationFrame
            updateAmbientParticles();
            
            requestAnimationFrame(gameLoop);
        }

        // Remove original particle creation from click handler
        canvas.addEventListener('click', (e) => {
            // ... (keep energy and score logic)
            
            // Remove createParticles(x, y) call
        });
    </script>
</body>
</html>
